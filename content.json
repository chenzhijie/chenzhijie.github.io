{"pages":[{"title":"Chen Zhijie","text":"专业: Golang / iOS / Node.js 开发者 公司: 目前就职于 Onchain 北京 联系方式: Email : zhijieit@gmail.com WeChat : opzhuyi","link":"/about/index.html"}],"posts":[{"title":"ethereum-blocksync","text":"以太坊区块同步原理分析以太坊区块同步，主要有三个模式 Full, Fast, Light。 其中Full是同步区块头和区块数据。以下分析主要分析核心思路，大致的算法过程。 一、部分源码分析以太坊同步的过程主要是依赖下载器downloader进行同步，通过peer的一些标志来筛选节点。将任务放到优先级队列里面加快同步速度。其他的代码起到辅助作用。 queue.go : 优先级队列实现。处理请求，响应的优先级队列。包括同步区块头部和区块body。 peer.go: 记录peer的吞吐量，RTT，是否空闲等数据，同时对peer的注册和注销进行管理 downloader.go: 主要的下载任务实现逻辑。 二、FullSync 区块同步过程区块头： 根据TD最大值筛选出节点，同步最长链的节点 同步区块头完成之后，进入fetchbody， 主要三步为： 根据当前计算的TTL 设置超时时间， 根据RTT计算该节点可以请求的节点的block的容量capacity 根据peerSet返回当前空闲的peer, 并且按照吞吐量排序 三、fetchBodies过程分析fetchbodies是同步块的主要函数，通过找到一部分可以使用的节点，向这些节点派送同步区块的任务，并发进行。同时检查是否有存在超时。 qosTuner 服务定时更新RTT。根据impact系数，所有节点的RTT中位数，计算新一轮的RTT。同时更新d.rttConfidence， 以当前的RTT时间作为下一轮开始的delay。 requestTTL计算过程 参数 计算 d.rttEstimate 根据qosTuner 服务，定时更新 d.rttConfidence 新peer加入，更新conf ttlScaling 3 (定值) ttlLimit 1分钟（定值） requestRTT计算过程0.9 *d.rttEstimate 原因是该RTT可能被多次获取，适当降低有利于稳定传输 四、FullSync时序图 local->peer: handshake peer->local: handshake Note over local: pm.synchronise(bestPeer) Note over local: downloader.Synchronise(bestPeer) local->peer: downloader.syncWithPeer(bestPeer) Note over local: downloader.fetchBodies() Note over local: downloader.fetchParts() Note over local: loop idle peers local->peer: fetch bodies{\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","link":"/2018/09/11/ethereum-blocksync/"},{"title":"ipfs-p2p-bitswap","text":"IPFS P2P网络原理 以及 Bitswap的数据交互流程 关于IPFS的P2P网络相关分析是基于 v0.4.15 commit: 8671f7bb9f1409a60e97666422ff87017dc4cbfc 首先IPFS执行初始化， 先配置 IPFS_PATH , 比方是当前目录 1$ export IPFS_PATH = $PWD 初始化 1$ ipfs init IPFS初始化时会在本地生成一个默认的 config 文件 这个config文件会有一些ip和端口的配置，配置的就是本地的 host 然后在 builder.go 文件里的 setupNode 函数会调用 startOnlineServices 将配置文件中的相关信息传参，从而建立IPFS host bitswap 是一个数据块交互的网络实现， 每个IPFS节点有一个bitswap网络。 通过wantmanager进行管理, 而wantmanager 里面又实现了队列机制。 如果队列有消息需要发送的话，首先判断msgQueue 的sender是否为nil，则会先建立连接，生成一个 sender 然后发送数据。 bitswap 的一些操作命令，基本都是查看数据交互过程的一些数据信息展示， 实际操作主要还是利用到 ipfs block get 等相关命令 ipfs block get 后面带着指定的块 cid ， 会先从本地blockstore里面判断是否有指定的块，如果没有则根据当前网络连接的情况， 将所需要的 块 放在 wantlist里面，形成一个 work， 触发当前的 msgQueue的事件循环机制doWork 去执行，发送bitswap 消息 从而从其他节点中获取到需要的块。 获取一个数据block的时序图 participant Node participant Peer Note over Node:getCmd -> bitswap.getBlock() Note over Node:generate work Note over Node:work picked by msgQueue Node->Peer: streamMessageSender.SendMsg() Note over Peer: accepted in handleNewStream() Note over Peer: bitswap.ReceiveMessage() Note over Peer: bitswap.engine.MessageReceived() Note over Peer: push entry to peer_request_queue Note over Peer: wantmanager.SendBlock() Peer->Node:bsnet.SendMessage() Note over Node: accepted in handleNewStream() Note over Node: bitswap.ReceiveMessage() Note over Node: put to blockstore Note over Node: engine.AddBlock(){\"theme\":\"simple\"} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","link":"/2018/08/22/ipfs-p2p-bitswap/"}],"tags":[{"name":"ipfs","slug":"ipfs","link":"/tags/ipfs/"},{"name":"ethereum","slug":"ethereum","link":"/tags/ethereum/"}],"categories":[]}